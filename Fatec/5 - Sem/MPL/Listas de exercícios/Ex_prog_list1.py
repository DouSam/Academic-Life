# -*- coding: utf-8 -*-
"""Programação Linear

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18FLz8ITSHDu9b7TDHUmANKJrGVMVnxuX
"""

# Instalando a biblioteca PyMathProg
!pip install pymprog

from pymprog import* # Importando a biblioteca

# Dados de entrada
R = [3, 2] # receita das ligas
D = [3, 1, 3] # disponibilidade das matérias-primas
P = [[0.5, 0.3],
     [0.1, 0.2],
     [0.4, 0.5]] # percentuais de matérias-primas nas ligas

n = len(R) # número de ligas
m = len(D) # número de matérias-primas

begin("ligas") # inicia um modelo chamado ligas

# variáveis de decisão
x = var("x", n, int) # cria n variáveis contínuas x0, x1, ..., xn-1

# função objetivo
maximize(sum(R[i] * x[i] for i in range(n)))

# restrições
for j in range(m):
  sum(P[j][i] * x[i] for i in range(n)) <= D[j]

# resolvendo
solve()

# apresentando o resultado

# valor ótimo
print("Valor ótimo = {:.3f}".format(vobj()))
# solução ótima
for i in range(n):
  print("x[{}] = {:.3f}".format(i+1, x[i].primal))

end()

from pymprog import* # Importando a biblioteca

# Dados de entrada
# Parametros
P = [10, 25, 20] # Preco de venda de cada produto
C = [6 , 15, 14] # Custo de cada produto
A = [1000, 0, 100] # Minimo de vendas de cada produto
B = [6000, 500, 1000] # Maximo de vendas de cada produto
D = [400, 400, 500, 2000] # Disponibilidade dos recurso
Q = [
     [0.03, 0.15, 0.1],
     [0.06, 0.12, 0.1],
     [0.05, 0.1, 0.12],
     [0, 2, 1.2]
] # Quantidade de recurso utilizado por produto

n = len(P) # Produtos
m = len(D) # Recursos

begin("Fabrica de utensilio") # Inicia o modelo
verbose("True") # Demonstrar o modelo
# Variaveis de decisao
x = var("x",n, int) # Criando as variaveis de decisão inteiras. Quantidade de compra de cada produto

# Funcao objetivo
maximize(sum((P[i] - C[i]) * x[i] for i in range(n)))

# Restricoes
for j in range(m): # Restricao de quantidade de recurso por setor
  sum(Q[j][i] * x[i] for i in range(n)) <= D[j]

for i in range(n): # Restricao de minimo e maximo de vendas
  A[i] <= x[i] <= B[i]

solve() # Resolvendo o modelo

# Valor otimo, solução otima
print("Valor ótimo = {}".format(vobj()))

# Solução ótima
for i in range(n):
  print("x[{}] = {}".format(i + 1, x[i].primal))

for j in range(m):
  print("Recurso {}: {}".format(j+1,sum(Q[j][i] * x[i].primal for i in range(n))))
end()

from pymprog import *

# Dados de entrada
P = [80, 90] # produção das fazendas
D = [50, 40, 65] # demanda de cada cliente
CFP = [
       [10, 12, 20],
       [15, 8, 11]
] # custo de envio da fazenda para o centro de custo
CPC = [
       [7, 7, 20],
       [8, 9, 10],
       [24, 8, 6]
] # custo de envio do centro de distribuicao para o cliente

n = len(P)   # numero de fazendas
m = len(CPC) # numero de centros
l = len(D)   # numero de clientes

begin("Transporte de carnes") # Inicia o modelo

A = iprod(range(n),range(m)) # cria os indices para a variavel x
x = var("x", A) # cria a variavel x

B = iprod(range(m), range(l)) # cria os indices para a variavel y
y = var("y", B) # cria a variavel y

# Funcao objetiva
minimize(sum(CFP[i][j] * x[i, j] for i,j in A) + sum(CPC[j][k] * y[j, k] for j,k in B))

# Restrições

for k in range(l): # Demanda
  sum(y[j,k] for j in range(m)) == D[k]

for i in range(n): # Producao
  sum(x[i,j] for j in range(m)) <= P[i]

for j in range(m):
  sum(x[i,j] for i in range(n)) == sum(y[j,k] for k in range(l))

solve()

print("Valor ótimo = {}".format(vobj()))

for i,j in A:
  print("x[{},{}] = {}".format(i+1,j+1,x[i,j].primal))
  
for j,k in B:
  print("y[{},{}] = {}".format(j+1,k+1,y[j,k].primal))

end()

from pymprog import* # Importando a biblioteca

# Dados de entrada
# Parametros
D = [960, 510, 895] # Demanda
E = [1100, 1800] # Estoque
C = [
     [3.70, 4.30, 6.1],
     [9.80, 6.90, 2.1]
] # Custo

n = len(E) # Distribuidoras
m = len(D) # Consumidores

begin("Fabricante de Bebidas") # Inicia o modelo
verbose("True") # Demonstrar o modelo

# Variaveis de decisao
A = iprod(range(n), range(m)) # Cria os indices das variaveis
x = var("x", A, int) # Quantidade enviada da distribuidora i para consumidor j

# Funcao objetivo
minimize(sum(x[i,j]*C[i][j] for i,j in A))

# Restricoes
for j in range(m): # Atendimento da demanda do consumidor
  sum(x[i,j] for i in range(n)) == D[j]

for i in range(n): # Enviar somente o disponivel pelo centro
  sum(x[i,j] for j in range(m)) <= E[i]

solve() # Resolvendo o modelo

# Valor otimo, solução otima
print("Valor ótimo = {}".format(vobj()))

# Solução ótima
for i, j in A:
  print("x[{},{}] = {}".format(i + 1, j + 1, x[i,j].primal))

for i in range(n):
  print("D[{}] = {}".format(i,sum(x[i,j].primal for j in range(m))))

end()

from pymprog import* # Importando a biblioteca

# Dados de entrada
# Parametros
C = [5.20, 6.8, 7.10, 2.50] # Custo por kilo de cada ingrediente
P = [
     [0.26, 0.05, 0.60, 0.07],
     [0.01, 0.05, 0.75, 0],
     [0.25, 0.26, 0.45, 0.01],
     [0.10, 0.02, 0.24, 0.01]
] # Percentual do nutriente para cada ingrediente
A = [1, 1, 0.55, 0.08] # Maximo do nutriente por barra
B = [0.22, 0.07, 0, 0] # Minimo do nutriente por barra

n = len(C) # Ingredientes
m = len(A) # Nutrientes

begin("Fabrica de Alimentos") # Inicia o modelo
#verbose("True") # Demonstrar o modelo
# Variaveis de decisao
X = var("x",n, float) # Quantidade fabricada de cada ingrediente

# Funcao objetivo
minimize(sum(X[i] * C[i] for i in range(n)))

# Restricoes
for j in range(m): # Restricao de maximo do nutriente j
  sum(X[i] * P[i][j] for i in range(n)) <= A[j]

for j in range(m): # Restricao de minimo do nutriente j
  sum(X[i] * P[i][j] for i in range(n)) >= B[j]

for i in range(n): # Restricao de positividade
  X[i] >= 0

sum(X[i] for i in range(n)) == 1 # Restricao de unidade

solve() # Resolvendo o modelo

# Valor otimo, solução otima
print("Custo mínimo = {:.5f}".format(vobj()))

# Solução ótima
for i in range(n):
  print("Total utilizado do ingrediente {}: {:.4f}Kg".format(i + 1, X[i].primal))
end()

from pymprog import *

# Dados de entrada
T = [54, 83, 15, 71, 77, 36, 53, 38, 27, 87, 76, 91, 14, 29, 12, 77, 32, 87, 
     68, 94, 79, 3, 11, 99, 56, 70, 99, 60, 5, 56, 3, 61, 73, 75, 47, 14, 21,
     86, 5, 77, 16, 89] 

n = 6 # numero de operadores
m = len(T) # numero de tarefas

begin("Diminuindo o makespan") # Inicia o modelo

A = iprod(range(n),range(m)) # cria os indices para a variavel x
x = var("x", A, bool) # cria a variavel x

z = var("z") # cria a variavel y

# Funcao objetiva
minimize(z)

# Restrições

for j in range(m):
  sum(x[i,j] for i in range(n)) == 1

for i in range(n):
  sum(T[j]*x[i,j] for j in range(m)) <= z

z >= 0

solve()

print("Valor ótimo = {}".format(vobj()))

operadorAtual = -1

for i,j in A:
  if(operadorAtual != i):
    operadorAtual = i
    print("\nOperador {} executa as tarefas: ".format(i+1),end="")
  if(x[i,j].primal == 1):
    print("{}, ".format(j+1),end="")

end()

# http://pymprog.sourceforge.net/index.html

from pymprog import *

# Dados de entrada
D = [
     [900, 1500, 1300],
     [700, 900, 800]
] # Demanda da bebida i no periodo j
C = [
     [1.5, 1.5, 2.0],
     [0.5, 0.5, 0.8]
] # Custo de producao da bebida i no periodo j
CE = [
      [0.5, 0.25, 0],
      [0.25, 0.25, 0]
] # Custo de estoque da bebida i no periodo j
CP = [
      [200, 400, 400],
      [400, 500, 500]
] # Custo de preparação da bebida i no periodo j
T = [100/1000, 80/1000] # Tempo de produção
TL = [12, 8] # Tempo de limpeza da bebida i
TD = [250, 320, 200] # Tempo disponivel do tanque por periodo j

n = len(T) # Numero de bebidas
m = len(TD) # Numero de periodos

begin("Fabrica de Refrigerantes") # Inicia o modelo
#verbose("True") # Demonstrar o modelo
A = iprod(range(n),range(m)) # cria os indices para a variavel x
x = var("x", A) # cria a variavel x
B = iprod(range(n),range(-1,m))
y = var("y", B)
s = var("s", A, bool)

M = sum(D[i][j] for i,j in A)

# Funcao objetiva
minimize(sum(C[i][j] * x[i,j] + CE[i][j] * y[i,j] + CP[i][j] * s[i,j] for i,j in A))

# Restrições

for i,j in A:
  x[i,j] + y[i,j-1] - y[i,j] == D[i][j]

for i in range(n):
  y[i,-1] == 0

for j in range(m):
  sum((T[i] * x[i,j] + TL[i] * s[i,j]) for i in range(n)) <= TD[j]

for i,j in A:
  x[i,j] <= M * s[i,j]

solve()

print("Valor ótimo = {}".format(vobj()))

for i, j in A:
  print('X[{0}, {1}] = {2}            Y[{0}, {1}] = {3}'.format(i + 1, j + 1, x[i, j].primal, y[i, j].primal))

end()

# http://pymprog.sourceforge.net/index.html

# TRABALHO 2
from pymprog import *

# Dados de entrada
E = [1, 2, 5, 3, 2, 6, 3, 2] # Quantidade de barcos encomendados para o mes i

n = len(E) # Numero de meses

begin("Construtor de Barcos") # Inicia o modelo
#verbose("True") # Demonstrar o modelo

x = var("x", n, int) # quantidade de barcos construído no mês i
y = var("y", range(-1,n), int) # quantidade de barcos armazenados no mês i
c = var("c", n, bool) # 1 se construido barco no mes i, 0 se contrario
M = sum(E[i] for i in range(n)) 

# Funcao objetiva
minimize(sum(x[i] * 10000 + c[i] * 4000 + y[i] * 1000 for i in range(n)))

# Restrições

for i in range(n):
  x[i] + y[i-1] - y[i] == E[i] # atendimento da encomenda

for i in range(n):
  x[i] <= 4 # maximo de barcos construidos em um mes

for i in range(n):
  y[i] <= 3 # maximo de barcos estocados em um mes

for i in range(n):
  x[i] <= M * c[i] # acoplamento entre x e c

y[-1] == 0 # inicia o estoque em 0

solve()

print("Valor ótimo = {}".format(vobj()))

for i in range(n):
  print("Quantidade de barcos contruídos - estocados no mês x[{}]: {} - {}".format(i+1, x[i].primal, y[i].primal))

end()

# http://pymprog.sourceforge.net/index.html

